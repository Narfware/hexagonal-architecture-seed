# # This image replaces the one previously provided in the runner registry
# image: trazable/ci:1.0.2

# services:
#     - docker:18.06-dind

# variables:
#     DOCKER_HOST: tcp://docker:2375 ## Uses the previous container as a host
#     DOCKER_DRIVER: overlay2 ## Performance

#     REGISTRY_CONSUS_URL: $REGISTRY_CONSUS_HOST/$CONSUS_GROUP/$CONSUS_PROJECT_NAME
#     REGISTRY_GCLOUD_STAGING_URL: $REGISTRY_GCLOUD_HOST/$GCLOUD_STAGING_PROJECT/$CONSUS_PROJECT_NAME
#     REGISTRY_GCLOUD_PLAYGROUND_URL: $REGISTRY_GCLOUD_HOST/$GCLOUD_PLAYGROUND_PROJECT/$CONSUS_PROJECT_NAME
#     REGISTRY_GCLOUD_PRODUCTION_URL: $REGISTRY_GCLOUD_HOST/$GCLOUD_PRODUCTION_PROJECT/$CONSUS_PROJECT_NAME

# before_script:
#     # Login to gitlab-trazable registry
#     - echo $CI_ROOT_ACCESS_TOKEN_PASSWORD | docker login -u $CI_ROOT_ACCESS_TOKEN_USER --password-stdin $REGISTRY_CONSUS_HOST
#     # Write our GCP service account private key into a file
#     - echo $CD_STAGING_DEPLOY_TOKEN > google_service_account.json

# # Stages involved in the pipeline
# stages:
#     - build
#     - test
#     - deploy

# compile:
#     stage: build
#     only:
#         - develop
#         - /^release\/.*$/
#         - /^hotfix\/.*$/
#         - master
#     script:
#         # Build development image with the needed env vars provided by the Consus runner in order to pass unit tests and compile a development version
#         - docker build
#             --build-arg GCLOUD_PROJECT_ID=$GCLOUD_STAGING_PROJECT
#             --build-arg KMS_LOCATION=$KMS_LOCATION
#             --build-arg KMS_KEYRING=$KMS_KEYRING
#             --build-arg KMS_KEY_WALLETS=$KMS_KEY_WALLETS
#             --build-arg KMS_KEY_CREDENTIALS=$KMS_KEY_CREDENTIALS
#             --build-arg SECRETS_BUCKET=$SECRETS_DEVELOPMENT_BUCKET
#             --build-arg ETH_NETWORK=$ETH_NETWORK
#             --build-arg ENVIRONMENT_VARIABLES_FILENAME=$ENVIRONMENT_VARIABLES_FILENAME
#             --build-arg MONGO_VARIABLES_FILENAME=$MONGO_VARIABLES_FILENAME
#             --build-arg TELEGRAM_VARIABLES_FILENAME=$TELEGRAM_VARIABLES_FILENAME
#             --build-arg IMAGES_BUCKET=$IMAGES_STAGING_BUCKET
#             --tag $REGISTRY_CONSUS_URL:$CI_COMMIT_SHORT_SHA-build-dev
#             --target development .
#         # Push development version image to the Consus registry
#         - docker push $REGISTRY_CONSUS_URL:$CI_COMMIT_SHORT_SHA-build-dev


# # e2e test (WITH REAL SERVICE)
# e2e:
#     stage: test
#     only:
#         - /^release\/.*$/
#         - /^hotfix\/.*$/
#     script:
#         # Build production image with the needed env vars provided by the Consus runner in order to pass e2e tests and compile a staging version
#         - docker build
#             --build-arg GCLOUD_PROJECT_ID=$GCLOUD_STAGING_PROJECT
#             --build-arg KMS_LOCATION=$KMS_LOCATION
#             --build-arg KMS_KEYRING=$KMS_KEYRING
#             --build-arg KMS_KEY_WALLETS=$KMS_KEY_WALLETS
#             --build-arg KMS_KEY_CREDENTIALS=$KMS_KEY_CREDENTIALS
#             --build-arg SECRETS_BUCKET=$SECRETS_STAGING_BUCKET
#             --build-arg ETH_NETWORK=$ETH_NETWORK
#             --build-arg ENVIRONMENT_VARIABLES_FILENAME=$ENVIRONMENT_VARIABLES_FILENAME
#             --build-arg MONGO_VARIABLES_FILENAME=$MONGO_VARIABLES_FILENAME
#             --build-arg TELEGRAM_VARIABLES_FILENAME=$TELEGRAM_VARIABLES_FILENAME
#             --build-arg IMAGES_BUCKET=$IMAGES_STAGING_BUCKET
#             --tag $REGISTRY_CONSUS_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-build-prod
#             --target production .

#         # PASS e2e TESTS
#         #- echo e2e failed successfully

#         # Tag image as tests passed
#         - docker tag
#             $REGISTRY_CONSUS_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-build-prod
#             $REGISTRY_CONSUS_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-test

#         # Push tested production version image to the Consus registry
#         - docker push $REGISTRY_CONSUS_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-test

# happy-path:
#     stage: test
#     only:
#         - /^release\/.*$/
#         - /^hotfix\/.*$/
#         - master
#     before_script:
#     # Login to gitlab-trazable registry
#     - echo $CI_ROOT_ACCESS_TOKEN_PASSWORD | docker login -u $CI_ROOT_ACCESS_TOKEN_USER --password-stdin $REGISTRY_CONSUS_HOST

#     script:
#         # Pull development image in order to pass the integration test
#         - docker pull $REGISTRY_CONSUS_URL:$CI_COMMIT_SHORT_SHA-build-dev
#         # Run with docker-compose mongo, mongo data feeder and the ganache cli, docker-compose create the network core-environment-network
#         - docker-compose up --detach mongo meeseek_mongo_feed ganache_cli
#         # Run the ethereum-api pulled of the consus registry
#         - docker run
#             --detach
#             --name ethereum_api
#             --network core-environment-network
#             --publish 8080:8080
#             $REGISTRY_CONSUS_URL:$CI_COMMIT_SHORT_SHA-build-dev
#         # Run wait-for-dependencies to ensure that the services are running before run the tests
#         - docker run
#             --name wait_for_dependencies
#             --network core-environment-network
#             --env TIMEOUT_LENGTH=60
#             dadarek/wait-for-dependencies
#             ethereum_api:8080 mongo:27017 ganache_cli:8545
#         # Happy path test
#         # Build the happy path image
#         - docker build
#             --file __tests__/Dockerfile
#             --tag happy_path .
#         # Run the container with the happy path to attack the ethereum-api
#         - docker run
#             --network core-environment-network
#             --name happy_path
#             happy_path
#     allow_failure: true
#     after_script:
#         - docker logs ethereum_api > ethereum_api-$CI_JOB_NAME-$(date +%Y-%m-%d)-logs.txt
#         - docker logs mongo > mongo-$CI_JOB_NAME-$(date +%Y-%m-%d)-logs.txt
#         - docker logs ganache_cli > ganache_cli-$CI_JOB_NAME-$(date +%Y-%m-%d)-logs.txt
#     artifacts:
#         when: always
#         paths:
#             - ethereum_api-$CI_JOB_NAME-$(date +%Y-%m-%d)-logs.txt
#             - mongo-$CI_JOB_NAME-$(date +%Y-%m-%d)-logs.txt
#             - ganache_cli-$CI_JOB_NAME-$(date +%Y-%m-%d)-logs.txt

# staging:
#     stage: deploy
#     only:
#         - /^release\/.*$/
#         - /^hotfix\/.*$/
#     before_script:
#         # Login to Consus registry
#         - echo $CI_ROOT_ACCESS_TOKEN_PASSWORD | docker login -u $CI_ROOT_ACCESS_TOKEN_USER --password-stdin $REGISTRY_CONSUS_HOST
#         # Write our GCP service account private key into a file
#         - echo $CD_STAGING_DEPLOY_TOKEN > google_service_account.json
#         # Activate the service account
#         - gcloud auth activate-service-account --key-file google_service_account.json
#     script:
#         # Pull production image in order to deploy it to staging environment
#         - docker pull $REGISTRY_CONSUS_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-test
#         # Tag prod image to release candidate for google cloud registry
#         - docker tag
#             $REGISTRY_CONSUS_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-test
#             $REGISTRY_GCLOUD_STAGING_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-rc
#         # Login to gcloud registry
#         - docker login -u _json_key --password-stdin https://$REGISTRY_GCLOUD_HOST < ./google_service_account.json
#         # Push rc image to gcloud registry
#         - docker push $REGISTRY_GCLOUD_STAGING_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-rc
#         # Deploy the rc image to staging
#         - gcloud app deploy
#             --image-url=$REGISTRY_GCLOUD_STAGING_URL:$(echo $CI_COMMIT_REF_NAME | cut -f 2 -d '/')-rc
#             --project=$GCLOUD_STAGING_PROJECT
#             --version=$CI_COMMIT_SHORT_SHA-rc
#             --quiet
#             --verbosity=debug
#             --no-promote
#             app.yaml
#     # Staging needs to be run manually
#     when: manual

# playground:
#     stage: deploy
#     only:
#         - master
#     before_script:
#         # Write our GCP service account private key into a file
#         - echo $CD_PLAYGROUND_DEPLOY_TOKEN > google_service_account.json
#         # Activate the service account
#         - gcloud auth activate-service-account --key-file google_service_account.json
#         # Login to gcloud registry
#         - docker login -u _json_key --password-stdin https://$REGISTRY_GCLOUD_HOST < ./google_service_account.json
#     script:
#            # Build production image with the needed env vars provided by the Consus runner in order to prepare an image to the playground environment
#         - docker build
#             --build-arg GCLOUD_PROJECT_ID=$GCLOUD_PLAYGROUND_PROJECT
#             --build-arg KMS_LOCATION=$KMS_LOCATION
#             --build-arg KMS_KEYRING=$KMS_KEYRING
#             --build-arg KMS_KEY_WALLETS=$KMS_KEY_WALLETS
#             --build-arg KMS_KEY_CREDENTIALS=$KMS_KEY_CREDENTIALS
#             --build-arg SECRETS_BUCKET=$SECRETS_PLAYGROUND_BUCKET
#             --build-arg ETH_NETWORK=$ETH_NETWORK
#             --build-arg ENVIRONMENT_VARIABLES_FILENAME=$ENVIRONMENT_VARIABLES_FILENAME
#             --build-arg MONGO_VARIABLES_FILENAME=$MONGO_VARIABLES_FILENAME
#             --build-arg TELEGRAM_VARIABLES_FILENAME=$TELEGRAM_VARIABLES_FILENAME
#             --build-arg IMAGES_BUCKET=$IMAGES_PLAYGROUND_BUCKET
#             --tag $REGISTRY_GCLOUD_PLAYGROUND_URL:$CI_COMMIT_SHORT_SHA-playground
#             --target production .
#         # Push playground image to gcloud registry
#         - docker push $REGISTRY_GCLOUD_PLAYGROUND_URL:$CI_COMMIT_SHORT_SHA-playground
#         # Deploy the playground image to playground
#         - gcloud app deploy
#             --image-url=$REGISTRY_GCLOUD_PLAYGROUND_URL:$CI_COMMIT_SHORT_SHA-playground
#             --project=$GCLOUD_PLAYGROUND_PROJECT
#             --version=$CI_COMMIT_SHORT_SHA-playground
#             --quiet
#             --verbosity=debug
#             --no-promote
#             app.yaml
#     # Playground needs to be run manually
#     when: manual

# production:
#     stage: deploy
#     only:
#         - master
#     before_script:
#         # Write our GCP service account private key into a file
#         - echo $CD_PRODUCTION_DEPLOY_TOKEN > google_service_account.json
#         # Activate the service account
#         - gcloud auth activate-service-account --key-file google_service_account.json
#         # Login to gcloud registry
#         - docker login -u _json_key --password-stdin https://$REGISTRY_GCLOUD_HOST < ./google_service_account.json
#     script:
#         # Build production image with the needed env vars provided by the Consus runner in order to pass unit tests and compile a production version
#         - docker build
#             --build-arg GCLOUD_PROJECT_ID=$GCLOUD_PRODUCTION_PROJECT
#             --build-arg KMS_LOCATION=$KMS_LOCATION
#             --build-arg KMS_KEYRING=$KMS_KEYRING
#             --build-arg KMS_KEY_WALLETS=$KMS_KEY_WALLETS
#             --build-arg KMS_KEY_CREDENTIALS=$KMS_KEY_CREDENTIALS
#             --build-arg SECRETS_BUCKET=$SECRETS_PRODUCTION_BUCKET
#             --build-arg ETH_NETWORK=$ETH_NETWORK
#             --build-arg ENVIRONMENT_VARIABLES_FILENAME=$ENVIRONMENT_VARIABLES_FILENAME
#             --build-arg MONGO_VARIABLES_FILENAME=$MONGO_VARIABLES_FILENAME
#             --build-arg TELEGRAM_VARIABLES_FILENAME=$TELEGRAM_VARIABLES_FILENAME
#             --build-arg IMAGES_BUCKET=$IMAGES_PRODUCTION_BUCKET
#             --tag $REGISTRY_GCLOUD_PRODUCTION_URL:$CI_COMMIT_SHORT_SHA-stable
#             --target production .
#         # Push stable image to gcloud registry
#         - docker push $REGISTRY_GCLOUD_PRODUCTION_URL:$CI_COMMIT_SHORT_SHA-stable
#         # Deploy the stable image to production without traffic promotion in order to last check the artifact still running with production env vars
#         - gcloud app deploy
#             --image-url=$REGISTRY_GCLOUD_PRODUCTION_URL:$CI_COMMIT_SHORT_SHA-stable
#             --project=$GCLOUD_PRODUCTION_PROJECT
#             --version=$CI_COMMIT_SHORT_SHA-stable
#             --quiet
#             --verbosity=debug
#             --no-promote
#             app.yaml
#     # Production needs to be run manually
#     when: manual
